/** * ============================================================================ * DataClean.gs - Data Cleaning Script for Party RSVP Responses * ============================================================================ *  * PURPOSE: * Cleans and standardizes party RSVP data from Google Forms responses. * - Filters to only guests marked "Checked-In = Y" in Form Responses 1 * - Standardizes inconsistent text entries (education levels, gender, etc.) * - Calculates zodiac signs from birthdays * - Preserves event day data (actual check-ins, photo uploads, name updates) *  * INPUT:  Form Responses 1 (raw Google Forms data) * OUTPUT: Form Responses (Clean) (standardized, filtered data) *  * SAFETY: * - Safe to re-run multiple times * - Preserves event day check-ins and updates from web app * - Logs all changes made during cleaning *  * WORKFLOW: * 1. Read Form Responses 1 (raw data with "Checked-In" column) * 2. Filter to only rows where Checked-In = "Y" * 3. Clean and standardize all text fields * 4. Calculate zodiac signs from birthdays * 5. Copy check-in timestamps from source * 6. Preserve any event day updates (screen names, photos) * 7. Write cleaned data to Form Responses (Clean) *  * TO USE: * Run cleanFormResponses() from Apps Script editor */// ============================================================================// MAIN FUNCTION// ============================================================================/** * Main entry point for data cleaning process * Reads Form Responses 1, filters to checked-in guests, cleans data, * and writes to Form Responses (Clean) */function cleanFormResponses() {  const ss = SpreadsheetApp.getActiveSpreadsheet();  const sourceSheet = ss.getSheetByName('Form Responses 1');    // Validate source sheet exists  if (!sourceSheet) {    SpreadsheetApp.getUi().alert('Error: "Form Responses 1" sheet not found!');    return;  }    // -------------------------------------------------------------------------  // STEP 1: Check if clean sheet already exists and preserve event data  // -------------------------------------------------------------------------  // If Form Responses (Clean) already exists, it may contain:  // - Updated screen names (changed via web app)  // - "Checked-In at Event" flags (actual party attendance)  // - Check-in timestamps (when guests arrived)  // - Photo URLs (uploaded photos)  // We must preserve this data before clearing and re-cleaning    let cleanSheet = ss.getSheetByName('Form Responses (Clean)');  const isExisting = cleanSheet !== null;    let existingEventData = {};  // Will store preserved data by UID    if (isExisting) {    Logger.log('Existing clean sheet found - preserving event day data...');    existingEventData = preserveEventDayData(cleanSheet);    cleanSheet.clear();  // Clear old data (will restore event data in step 5)  } else {    Logger.log('Creating new clean sheet...');    cleanSheet = ss.insertSheet('Form Responses (Clean)');  }    // -------------------------------------------------------------------------  // STEP 2: Load source data and identify columns  // -------------------------------------------------------------------------  const data = sourceSheet.getDataRange().getValues();  const headers = data[0];      // First row contains column names  const allRows = data.slice(1); // All data rows (exclude header)    // Find column indices by name (returns -1 if not found)  const colMap = {    screenName: headers.indexOf('Screen Name'),    uid: headers.indexOf('UID'),    checkedIn: headers.indexOf('Checked-In'),        // Pre-approval flag    checkInTime: headers.indexOf('Check-in Time')    // When they checked in (from Form Responses 1)  };    // Validate required columns exist  if (colMap.screenName === -1 || colMap.uid === -1 || colMap.checkedIn === -1) {    SpreadsheetApp.getUi().alert('Error: Required columns (Screen Name, UID, Checked-In) not found!');    return;  }    // -------------------------------------------------------------------------  // STEP 3: Filter to only checked-in guests  // -------------------------------------------------------------------------  // Only process rows where "Checked-In" column = "Y"  // This filters out:  // - Guests who haven't been approved  // - Test responses  // - Empty pre-generated UID rows at bottom of sheet    const rows = allRows.filter(row => {    const checkedIn = String(row[colMap.checkedIn] || '').trim().toUpperCase();    return checkedIn === 'Y';  // Only include approved guests  });    if (rows.length === 0) {    SpreadsheetApp.getUi().alert('No checked-in guests found! Make sure "Checked-In" column has "Y" values.');    return;  }    Logger.log(`Found ${rows.length} checked-in guests out of ${allRows.length} total rows`);    // -------------------------------------------------------------------------  // STEP 4: Define output schema  // -------------------------------------------------------------------------  // Column structure for Form Responses (Clean)  // - Columns 1-21: Cleaned survey response data  // - Columns 22-23: Tracking identifiers (Screen Name, UID)  // - Columns 24-26: Event day data (check-in status, timestamp, photo)    const newHeaders = [    'Timestamp',                                      // Col 1  - Form submission time    'Birthday (MM/DD)',                               // Col 2  - Cleaned birthday format    'Zodiac Sign',                                    // Col 3  - Calculated from birthday    'Age Range',                                      // Col 4  - 21-24, 25-29, etc.    'Education Level',                                // Col 5  - Standardized education    'Current 5 Digit Zip Code',                       // Col 6  - Cleaned zip code    'Self Identified Ethnicity',                      // Col 7  - Standardized ethnicity    'Self-Identified Gender',                         // Col 8  - Standardized gender    'Self-Identified Sexual Orientation',             // Col 9  - Standardized orientation    'Employment Information (Industry)',              // Col 10 - Grouped industry    'Employment Information (Role)',                  // Col 11 - Grouped job role    'Do you know the Host(s)?',                       // Col 12 - Standardized duration    'Which host have you known the longest?',         // Col 13 - Michael/Jacob/Equal    'If yes, how well do you know them?',             // Col 14 - Closeness score (1-5)    'Your General Interests (Choose 3)',              // Col 15 - Cleaned interests list    'Music Preference',                               // Col 16 - Standardized genre    'Current Favorite Artist',                        // Col 17 - Artist name (raw)    'Name one song you want to hear at the party.',   // Col 18 - Song request (raw)    'Recent purchase you\'re most happy about',       // Col 19 - Standardized category    'At your worst you are…',                         // Col 20 - Standardized trait    'Which best describes your general social stance?', // Col 21 - Social score (1-5)    'Screen Name',                                    // Col 22 - Guest screen name    'UID',                                            // Col 23 - Unique identifier    'Checked-In at Event',                            // Col 24 - Actually attended? (Y/blank)    'Check-In Timestamp',                             // Col 25 - When they arrived at party    'Photo URL'                                       // Col 26 - Uploaded photo link  ];    const cleanedData = [newHeaders];  // Start with header row  const cleaningLog = [];            // Track all changes made    // -------------------------------------------------------------------------  // STEP 5: Process each row - clean data and restore event info  // -------------------------------------------------------------------------  rows.forEach((row, idx) => {    const rowNum = idx + 2;  // +2 because: +1 for header, +1 for 0-based index        // Clean the row and restore any preserved event data    const cleanedRow = processRow(row, rowNum, colMap, cleaningLog, existingEventData);        if (cleanedRow) {      cleanedData.push(cleanedRow);    }  });    // -------------------------------------------------------------------------  // STEP 6: Write cleaned data to output sheet  // -------------------------------------------------------------------------  if (cleanedData.length > 1) {  // At least header + 1 data row    // Write all data at once (more efficient than row-by-row)    cleanSheet.getRange(1, 1, cleanedData.length, cleanedData[0].length)      .setValues(cleanedData);        // Format header row (blue background, white text, bold)    cleanSheet.getRange(1, 1, 1, newHeaders.length)      .setFontWeight('bold')      .setBackground('#4285f4')      .setFontColor('white');        // Freeze header row so it stays visible when scrolling    cleanSheet.setFrozenRows(1);        // Auto-resize all columns to fit content    cleanSheet.autoResizeColumns(1, newHeaders.length);        // Highlight tracking columns (Screen Name + UID) in darker blue    cleanSheet.getRange(1, 22, cleanedData.length, 2)      .setBackground('#1e88e5');        // Highlight event day columns (check-in data) in green    cleanSheet.getRange(1, 24, cleanedData.length, 3)      .setBackground('#34a853');  }    // -------------------------------------------------------------------------  // STEP 7: Create cleaning log sheet  // -------------------------------------------------------------------------  // Records all changes made during cleaning for audit trail  createCleaningLog(ss, cleaningLog);    // Show completion message  const preservedCount = Object.keys(existingEventData).length;    SpreadsheetApp.getUi().alert(    `✅ Cleaning complete!\n\n` +    `Total in Form Responses 1: ${allRows.length}\n` +    `Approved (Checked-In = Y): ${rows.length}\n` +    `Filtered out: ${allRows.length - rows.length}\n` +    `Cleaned rows: ${cleanedData.length - 1}\n` +    `${preservedCount > 0 ? `Preserved event data for ${preservedCount} guests\n` : ''}` +    `\nCheck "Cleaning Log" sheet for details.`  );}// ============================================================================// DATA PRESERVATION// ============================================================================/** * Preserves event day data from existing Form Responses (Clean) sheet *  * WHY THIS IS NEEDED: * During the party, guests check in via a web app which updates: * - Screen names (if they want to change it) * - Check-in status (marks them as actually present) * - Check-in timestamp (when they arrived) * - Photo URL (if they upload a photo) *  * When we re-run the cleaning script to process new form submissions, * we must preserve this event day data. Otherwise it would be lost. *  * PROCESS: * 1. Read existing Form Responses (Clean) sheet * 2. Extract event day data for each guest (keyed by UID) * 3. Store in an object: { UID: {screenName, checkedInAtEvent, timestamp, photoUrl} } * 4. Return this object to be used during row processing *  * @param {Sheet} sheet - The existing Form Responses (Clean) sheet * @return {Object} Map of UID -> event day data */function preserveEventDayData(sheet) {  const preserved = {};    try {    const data = sheet.getDataRange().getValues();    if (data.length < 2) return preserved;  // No data to preserve        const headers = data[0];        // Find event day columns in existing sheet    const colMap = {      uid: headers.indexOf('UID'),      screenName: headers.indexOf('Screen Name'),      checkedIn: headers.indexOf('Checked-In at Event'),      timestamp: headers.indexOf('Check-In Timestamp'),      photo: headers.indexOf('Photo URL')    };        // Can't map without UID column    if (colMap.uid === -1) return preserved;        // Loop through each guest and save their event day data    for (let r = 1; r < data.length; r++) {      const row = data[r];      const uid = String(row[colMap.uid] || '').trim();            if (!uid) continue;  // Skip rows without UID            // Store all event day data for this guest      preserved[uid] = {        screenName: colMap.screenName !== -1 ? row[colMap.screenName] : null,        checkedInAtEvent: colMap.checkedIn !== -1 ? row[colMap.checkedIn] : null,        timestamp: colMap.timestamp !== -1 ? row[colMap.timestamp] : null,        photoUrl: colMap.photo !== -1 ? row[colMap.photo] : null      };    }        Logger.log(`Preserved event data for ${Object.keys(preserved).length} guests`);      } catch (error) {    Logger.log('Error preserving data: ' + error);  }    return preserved;}// ============================================================================// ROW PROCESSING// ============================================================================/** * Process a single row: clean all fields and restore event data *  * PROCESS: * 1. Extract and clean each survey field (columns 0-19) * 2. Calculate zodiac sign from birthday * 3. Extract tracking identifiers (Screen Name, UID) from source * 4. Copy check-in time from Form Responses 1 * 5. Check if this guest has preserved event day data * 6. If yes, restore their updated screen name, event check-in, timestamp, photo * 7. Return complete cleaned row (26 columns) *  * @param {Array} row - Raw data row from Form Responses 1 * @param {number} rowNum - Row number (for logging) * @param {Object} colMap - Column indices from source sheet * @param {Array} log - Cleaning log array (modified in place) * @param {Object} existingEventData - Preserved event data by UID * @return {Array} Cleaned row with 26 columns, or null if invalid */function processRow(row, rowNum, colMap, log, existingEventData) {  // Validate row has minimum required fields  if (!row || !Array.isArray(row) || row.length < 20) {    return null;  }    // -------------------------------------------------------------------------  // STEP 1: Clean all survey response fields (columns 0-19)  // -------------------------------------------------------------------------  const timestamp = row[0];  // Keep raw timestamp    // Birthday: standardize format to MM/DD or MM/DD/YYYY  const birthdayRaw = String(row[1] || '').trim();  const birthday = cleanBirthday(birthdayRaw);    // Zodiac: calculate from cleaned birthday  const zodiac = getZodiacSign(birthday);    // Keep these fields as-is (already clean from form)  const age = row[2];  const howWell = row[12];    // Standardize text fields (fix inconsistent capitalization, synonyms, typos)  const education = standardizeEducation(row[3]);  const zip = cleanZipCode(row[4]);  const ethnicity = standardizeEthnicity(row[5]);  const gender = standardizeGender(row[6]);  const orientation = standardizeOrientation(row[7]);  const industry = groupIndustry(row[8]);  const role = groupRole(row[9]);  const knowHost = standardizeKnowHost(row[10]);  const whichHost = standardizeHostName(row[11]);  const interests = cleanInterests(row[13]);  const music = standardizeMusicPreference(row[14]);  const purchase = standardizePurchase(row[17]);  const worst = standardizeWorstTrait(row[18]);  const social = cleanSocialStance(row[19]);    // Keep artist and song as-is (free text, many variations)  const artist = row[15] || 'Not Provided';  const song = row[16] || 'Not Provided';    // -------------------------------------------------------------------------  // STEP 2: Extract tracking identifiers from source  // -------------------------------------------------------------------------  const originalScreenName = row[colMap.screenName] || 'Unknown';  const uid = row[colMap.uid] || 'No UID';    // -------------------------------------------------------------------------  // STEP 3: Copy check-in time from Form Responses 1  // -------------------------------------------------------------------------  // This is the timestamp when they were marked "Checked-In = Y" in source  let sourceCheckInTime = '';  if (colMap.checkInTime !== -1) {    sourceCheckInTime = row[colMap.checkInTime] || '';  }    // -------------------------------------------------------------------------  // STEP 4: Check if this guest has preserved event day data  // -------------------------------------------------------------------------  // Event day data takes precedence over source data  // This preserves updates made via web app during the party    let finalScreenName = originalScreenName;  // May be updated  let checkedInAtEvent = '';                  // Did they actually show up?  let checkInTimestamp = sourceCheckInTime;   // When they arrived (default to source)  let photoUrl = '';                          // Uploaded photo    if (existingEventData && existingEventData[uid]) {    const preserved = existingEventData[uid];        // Use updated screen name if it exists (web app allows name changes)    if (preserved.screenName) {      finalScreenName = preserved.screenName;      if (finalScreenName !== originalScreenName) {        log.push(`Row ${rowNum}: Restored updated screen name for ${uid}: "${originalScreenName}" → "${finalScreenName}"`);      }    }        // Restore event day check-in data (actual party attendance)    if (preserved.checkedInAtEvent) {      checkedInAtEvent = preserved.checkedInAtEvent;    }        // Use event timestamp if available (overrides source timestamp)    if (preserved.timestamp) {      checkInTimestamp = preserved.timestamp;    }        // Restore photo URL    if (preserved.photoUrl) {      photoUrl = preserved.photoUrl;    }        // Log restoration of event check-in    if (checkedInAtEvent === 'Y') {      log.push(`Row ${rowNum}: Restored event check-in for ${uid} (${finalScreenName})`);    }  }    // -------------------------------------------------------------------------  // STEP 5: Log significant changes made during cleaning  // -------------------------------------------------------------------------  if (birthday !== birthdayRaw) {    log.push(`Row ${rowNum}: Birthday "${birthdayRaw}" → "${birthday}"`);  }    // -------------------------------------------------------------------------  // STEP 6: Return complete cleaned row (26 columns)  // -------------------------------------------------------------------------  return [    timestamp,          // Col 1  - Original form submission time    birthday,           // Col 2  - Cleaned birthday (MM/DD or MM/DD/YYYY)    zodiac,             // Col 3  - Calculated zodiac sign    age,                // Col 4  - Age range (21-24, 25-29, etc.)    education,          // Col 5  - Standardized education level    zip,                // Col 6  - Cleaned 5-digit zip code    ethnicity,          // Col 7  - Standardized ethnicity    gender,             // Col 8  - Standardized gender    orientation,        // Col 9  - Standardized sexual orientation    industry,           // Col 10 - Grouped industry category    role,               // Col 11 - Grouped job role    knowHost,           // Col 12 - Standardized friendship duration    whichHost,          // Col 13 - Which host (Michael/Jacob/Equal)    howWell,            // Col 14 - Closeness score (1-5)    interests,          // Col 15 - Cleaned interests list    music,              // Col 16 - Standardized music genre    artist,             // Col 17 - Favorite artist (raw)    song,               // Col 18 - Song request (raw)    purchase,           // Col 19 - Standardized purchase category    worst,              // Col 20 - Standardized personality trait    social,             // Col 21 - Social stance score (1-5)    finalScreenName,    // Col 22 - Screen name (may be updated from event)    uid,                // Col 23 - Unique identifier    checkedInAtEvent,   // Col 24 - Event day check-in flag (Y/blank)    checkInTimestamp,   // Col 25 - Check-in timestamp (from source or event)    photoUrl            // Col 26 - Photo URL (from event)  ];}// ============================================================================// CLEANING FUNCTIONS// ============================================================================// Each function standardizes a specific field type// Input: Raw text from Google Form// Output: Standardized, consistent text value/** * Clean birthday field * Handles various input formats: MM/DD, MM/DD/YYYY, MMDD, MMDDYYYY, (MM/DD) * Output: MM/DD or MM/DD/YYYY format */function cleanBirthday(birthday) {  if (!birthday) return 'Not Provided';    // Remove parentheses that some users add  birthday = birthday.replace(/[()]/g, '');    // Handle MMDDYYYY format (8 digits with no separators)  if (/^\d{8}$/.test(birthday)) {    return `${birthday.substring(0,2)}/${birthday.substring(2,4)}/${birthday.substring(4,8)}`;  }    // Handle MMDD format (4 digits with no separators)  if (/^\d{4}$/.test(birthday)) {    return `${birthday.substring(0,2)}/${birthday.substring(2,4)}`;  }    // Handle MM/DD or MM/DD/YYYY format (already has slashes)  const parts = birthday.split('/');  if (parts.length >= 2) {    const month = parts[0].padStart(2, '0');  // Ensure 2 digits    const day = parts[1].padStart(2, '0');    // Ensure 2 digits    return parts.length === 3 ? `${month}/${day}/${parts[2]}` : `${month}/${day}`;  }    // Can't parse - return as-is  return birthday;}/** * Calculate zodiac sign from birthday * Input: Birthday in MM/DD format * Output: Zodiac sign name or "Unknown" */function getZodiacSign(birthday) {  if (!birthday || birthday === 'Not Provided') return 'Unknown';    const parts = birthday.split('/');  if (parts.length < 2) return 'Unknown';    const month = parseInt(parts[0]);  const day = parseInt(parts[1]);    if (!month || !day) return 'Unknown';    // Zodiac date ranges  if ((month === 3 && day >= 21) || (month === 4 && day <= 19)) return 'Aries';  if ((month === 4 && day >= 20) || (month === 5 && day <= 20)) return 'Taurus';  if ((month === 5 && day >= 21) || (month === 6 && day <= 20)) return 'Gemini';  if ((month === 6 && day >= 21) || (month === 7 && day <= 22)) return 'Cancer';  if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return 'Leo';  if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return 'Virgo';  if ((month === 9 && day >= 23) || (month === 10 && day <= 22)) return 'Libra';  if ((month === 10 && day >= 23) || (month === 11 && day <= 21)) return 'Scorpio';  if ((month === 11 && day >= 22) || (month === 12 && day <= 21)) return 'Sagittarius';  if ((month === 12 && day >= 22) || (month === 1 && day <= 19)) return 'Capricorn';  if ((month === 1 && day >= 20) || (month === 2 && day <= 18)) return 'Aquarius';  if ((month === 2 && day >= 19) || (month === 3 && day <= 20)) return 'Pisces';    return 'Unknown';}/** * Standardize education level * Handles: "High School", "Some college", "Associate's", "Bachelor's", "Master's" */function standardizeEducation(edu) {  if (!edu) return 'Not Provided';  const e = String(edu).toLowerCase();  if (e.includes('high')) return 'High School';  if (e.includes('assoc')) return 'Associates';  if (e.includes('some')) return 'Some College';  if (e.includes('bach')) return 'Bachelors';  if (e.includes('master') || e.includes('above')) return 'Masters & Above';  return edu;}/** * Clean zip code - extract 5 digits */function cleanZipCode(zip) {  if (!zip) return 'Not Provided';  const match = String(zip).match(/\d{5}/);  return match ? match[0] : zip;}/** * Standardize ethnicity responses */function standardizeEthnicity(eth) {  if (!eth) return 'Not Provided';  const e = String(eth).toLowerCase();  if (e.includes('prefer not')) return 'Prefer Not to Say';  if (e.includes('not listed')) return 'Not Listed';  if (e.includes('mixed') || e.includes('multi')) return 'Mixed / Multiracial';  return eth;}/** * Standardize gender responses */function standardizeGender(gender) {  if (!gender) return 'Not Provided';  const g = String(gender).toLowerCase();  if (g === 'man' || g === 'male') return 'Man';  if (g === 'woman' || g === 'female') return 'Woman';  if (g.includes('non-binary')) return 'Non-binary';  if (g === 'other') return 'Other';  return gender;}/** * Standardize sexual orientation responses */function standardizeOrientation(ori) {  if (!ori) return 'Not Provided';  const o = String(ori).toLowerCase();  if (o.includes('straight') || o.includes('hetero')) return 'Straight / Heterosexual';  if (o === 'gay') return 'Gay';  if (o === 'lesbian') return 'Lesbian';  if (o.includes('bi')) return 'Bisexual';  if (o.includes('pan')) return 'Pansexual';  if (o === 'queer') return 'Queer';  return ori;}/** * Group industry into broader categories */function groupIndustry(ind) {  if (!ind) return 'Not Provided';  const i = String(ind).toLowerCase();  if (i.includes('hospital') || i.includes('retail')) return 'Hospitality / Retail';  if (i.includes('finance') || i.includes('business')) return 'Finance / Business Services';  if (i.includes('health')) return 'Healthcare';  if (i.includes('tech')) return 'Technology';  if (i.includes('art') || i.includes('entertain')) return 'Arts & Entertainment';  if (i.includes('edu')) return 'Education';  if (i.includes('science') || i.includes('research')) return 'Science / Research';  if (i.includes('trade') || i.includes('manufact')) return 'Trades / Manufacturing';  if (i.includes('gov') || i.includes('milit')) return 'Government / Military';  return ind;}/** * Group job role into broader categories */function groupRole(role) {  if (!role) return 'Not Provided';  const r = String(role).toLowerCase();  if (r.includes('manager') || r.includes('super')) return 'Manager / Supervisor';  if (r.includes('oper') || r.includes('admin') || r.includes('support')) return 'Operations / Admin / Support';  if (r.includes('sales') || r.includes('market')) return 'Sales / Marketing / Business Development';  if (r.includes('creat') || r.includes('design') || r.includes('artist')) return 'Creative / Designer / Artist';  if (r.includes('tech') || r.includes('eng') || r.includes('dev')) return 'Technical / Engineer / Developer';  if (r.includes('health') || r.includes('provider')) return 'Healthcare / Service Provider';  if (r.includes('research') || r.includes('scient')) return 'Researcher / Scientist';  if (r.includes('trade') || r.includes('labor')) return 'Trades / Skilled Labor';  if (r.includes('found') || r.includes('entrepr')) return 'Founder / Entrepreneur';  if (r.includes('educ') || r.includes('instruct')) return 'Educator / Instructor';  if (r.includes('student') || r.includes('train')) return 'Student / Trainee';  return role;}/** * Standardize "how long have you known the hosts" responses */function standardizeKnowHost(kh) {  if (!kh) return 'Not Provided';  const k = String(kh).toLowerCase();  if (k.includes('no')) return 'No';  if (k.includes('less than 3')) return 'Yes — less than 3 months';  if (k.includes('3–12') || k.includes('3-12')) return 'Yes — 3–12 months';  if (k.includes('1–3') || k.includes('1-3')) return 'Yes — 1–3 years';  if (k.includes('3–5') || k.includes('3-5')) return 'Yes — 3–5 years';  if (k.includes('5–10') || k.includes('5-10')) return 'Yes — 5–10 years';  if (k.includes('more than 10') || k.includes('10+')) return 'Yes — more than 10 years';  return kh;}/** * Standardize host names */function standardizeHostName(host) {  if (!host) return 'Not Provided';  const h = String(host).toLowerCase().trim();  if (h === 'jacob') return 'Jacob';  if (h === 'michael') return 'Michael';  if (h === 'equal') return 'Equal';  if (h.includes('do not know')) return 'Do Not Know Them';  return host;}/** * Clean interests field * Removes joke entries like "halloween orgy" or "frying oil" */function cleanInterests(int) {  if (!int) return 'Not Provided';  let i = String(int);  i = i.replace(/halloween orgy/gi, 'Halloween');  i = i.replace(/frying oil/gi, '');  return i.trim();}/** * Standardize music preference */function standardizeMusicPreference(music) {  if (!music) return 'Not Provided';  const m = String(music).toLowerCase();  if (m.includes('indie') || m.includes('alt')) return 'Indie/Alt';  if (m === 'pop') return 'Pop';  if (m.includes('hip')) return 'Hip-hop';  if (m.includes('r&b')) return 'R&B';  if (m === 'rock') return 'Rock';  if (m === 'metal') return 'Metal';  if (m.includes('elec')) return 'Electronic';  if (m.includes('country')) return 'Country';  if (m.includes('reggae')) return 'Reggaeton';  if (m.includes('prog')) return 'Prog Rock';  if (m.includes('amb')) return 'Ambient';  if (m.includes('emo')) return 'Emo';  if (m.includes('mix') || m.includes('all') || m.includes('every')) return 'Mixed / All Genres';  return music;}/** * Standardize recent purchase category */function standardizePurchase(purch) {  if (!purch) return 'Not Provided';  const p = String(purch).toLowerCase();  if (p.includes('tech') || p.includes('gadget')) return 'Tech gadget';  if (p.includes('fashion') || p.includes('cloth')) return 'Fashion/Clothing';  if (p.includes('home') || p.includes('kitchen')) return 'Home/Kitchen';  if (p.includes('pet')) return 'Pet item';  if (p.includes('fit') || p.includes('gear')) return 'Fitness gear';  if (p.includes('course') || p.includes('app')) return 'Course/App';  if (p.includes('car') || p.includes('motor')) return 'Car/Motorcycle';  return purch;}/** * Standardize "at your worst" personality trait */function standardizeWorstTrait(trait) {  if (!trait) return 'Not Provided';  const t = String(trait).toLowerCase();  if (t.includes('anx')) return 'Anxious';  if (t.includes('crit')) return 'Overly critical';  if (t.includes('stub')) return 'Stubborn';  if (t.includes('impul')) return 'Impulsive';  if (t.includes('reck')) return 'Reckless';  if (t.includes('guard')) return 'Guarded';  if (t.includes('jeal')) return 'Jealous';  if (t.includes('self-con')) return 'Self-conscious';  if (t.includes('insec')) return 'Insecure';  if (t.includes('distr')) return 'Distracted';  return trait;}/** * Clean social stance score (should be 1-5) */function cleanSocialStance(social) {  if (!social) return 'Not Provided';  const num = parseInt(social);  if (!isNaN(num) && num >= 1 && num <= 5) return num;  return social;}// ============================================================================// LOGGING// ============================================================================/** * Create or update Cleaning Log sheet * Records all changes made during cleaning for audit trail *  * @param {Spreadsheet} ss - Active spreadsheet * @param {Array} log - Array of log entries */function createCleaningLog(ss, log) {  let logSheet = ss.getSheetByName('Cleaning Log');  if (logSheet) {    logSheet.clear();  } else {    logSheet = ss.insertSheet('Cleaning Log');  }    const logData = [['Row Number', 'Change']];    // Parse log entries to extract row number and change description  log.forEach(entry => {    const match = entry.match(/Row (\d+): (.+)/);    if (match) {      logData.push([match[1], match[2]]);    }  });    if (logData.length > 1) {    logSheet.getRange(1, 1, logData.length, 2).setValues(logData);    logSheet.getRange(1, 1, 1, 2)      .setFontWeight('bold')      .setBackground('#f4b400');    logSheet.autoResizeColumns(1, 2);  }}